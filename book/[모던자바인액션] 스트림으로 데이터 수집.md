# 컬렉터란 무엇인가?
컬렉터 인터페이스 구현은 스트림의 요소를 어떤식으로 도출할지 지정한다.

# 리듀싱과 요약
컬렉터로 스트림의 모든 요소를 하나의 결과로 합칠 수 있다.

## 스트림값에서 최대값 최소값 검색
Collectors.maxBy()
- 스트림의 최대값 계산
- 스트림 요소를 비교하는데 Comparator를 인수로 받음
Collectors.minBy()
- 스트림ㄹ의 최소값 계산
- 스트림 요소를 비교하는데 Comparator를 인수로 받음

## 요약 연산
스트림에 있는 객체의 숫자 필드의 합계나 평균등을 반환하는 연산

Collectors.summingInt()
- 객체를 int로 매핑하는 함수를 인수로 받음
- int로 매핑된 요소의 총합 계산
- summingLong(), summingDouble도 존재

Collectors.averagingInt()
- 객체를 int로 매핑하는 함수를 인수로 받음
- int로 매핑된 요소의 평균 계산
- averagingLong(), averagingDouble도 존재

Collectors.summarizingInt()
- 하나의 요약 연산으로 수, 합계, 평균, 최댓값, 최소값을 구할 수 있음
- IntSummaryStatistics 클래스로 return
- summarizingLong, summarizingDouble도 존재


## 문자열 연결
joining()
- 스트림의 각 객체에 toString 메서드를 호출하여 추출한 모든 문자열을 하나의 문자열로 반환

## 범용 리듀싱 요약 연산
이전까지의 컬렉터는 reducing 메서드를 통해서도 정의할 수 있다.  
reducing()
- 첫 번째 인수는 리듀싱 연산의 시작값이거나 스트림에 인수가 없는경우 반환값
- 두 번째 인수는 변환 함수
- 세 번째 인수는 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator
- 한개의 인수만 넘겨준다면 BinaryOperator를 넘겨야함

# 그룹화
데이터 집합을 하나 이상의 특성으로 분류해서 그룹화하는 작업  
Collectors.groupingBy()
- 스트림의 요소들을 인수로 넘기는 함수를 기준으로 그룹화 하며 이 함수를 분류 함수라고 함
- 그룹화 연산의 결과로 그룹화 함수가 반환하는 키와 각 키에 대응하는 스트림의 모든 항목 리스트를 값으로 갖는 Map반환

```java
List<Book> books = asList(new Book("2022신상책", "홍길동", 2022, "IT"),
        new Book("이순신의 바다", "황현필", 2021, "History"),
        new Book("갈매기의 꿈", "리처드 바크", 2020, "Fiction"),
        new Book("모던 자바 인 액션", "라울-게이브리얼 우르마", 2020, "IT"),
        new Book("2019년 책", "홍길동", 2019, "IT"),
        new Book("이펙티브 자바", "조슈아 블로크", 2018, "IT")
);

Map<String, List<Book>> collect = books.stream().collect(Collectors.groupingBy(Book::getField));
```
결과
```
{IT=[Book{name='2022신상책', author='홍길동', year=2022, field='IT'}, Book{name='모던 자바 인 액션', author='라울-게이브리얼 우르마', year=2020, field='IT'}, Book{name='2019년 책', author='홍길동', year=2019, field='IT'}, Book{name='이펙티브 자바', author='조슈아 블로크', year=2018, field='IT'}], History=[Book{name='이순신의 바다', author='황현필', year=2021, field='History'}], Fiction=[Book{name='갈매기의 꿈', author='리처드 바크', year=2020, field='Fiction'}]}
```

## 그룹화된 요소 조작
요소를 그룹화 한 후에 각 결과 그룹의 요소를 조작하는 연산이 필요함.  
그룹화 전에 predicate로 필터를 적용해서 해결할 수도 있지만 이 경우 만족하는 결과가 없으면 키 자체가 사라진다.  
groupingBy의 두 번째 인수로 필터 predicate를 줘서 이를 해결할 수 있다.

```java
Map<String, List<Book>> collect2 = books.stream()
                .collect(Collectors.groupingBy(Book::getField, Collectors.filtering(book -> book.getYear() >= 2021, Collectors.toList())));
```

```
{IT=[Book{name='2022신상책', author='홍길동', year=2022, field='IT'}], History=[Book{name='이순신의 바다', author='황현필', year=2021, field='History'}], Fiction=[]}
```

mapping()
- 매핑함수와 각 항목의 적용한 함수를 모으는데 사용하는 메서드

```java
Map<String, List<String>> collect3 = books.stream()
                .collect(Collectors.groupingBy(Book::getField, Collectors.mapping(Book::getName, Collectors.toList())));
```



# 참고문서

모던 자바 인 액션 - 라울 게이브리얼 우르마, 마리오 푸스코, 앨런 마이크로소포트
