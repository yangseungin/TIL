# Thread 클래스와 Runnable 인터페이스

Thread 클래스와 RUnnable인터페이스를 알아보기전에 프로세스와 쓰레드에 대해 알아보자

## 프로세스(process)

OS로부터 메모리를 할당받아 실행중인 프로그램을 프로세스라고 한다.  
프로그램에 사용되는 데이터와 메모리 쓰레드로 구성된다.

## 쓰레드(thread)

프로세스내에서 실제로 작업을 수행하는 것으로 모든 프로세스는 하나 이상의 쓰레드를 가진다.  
두 개 이상의 쓰레드를 가지는 프로세스는 멀티 쓰레드 프로세스라고 한다.

## 쓰레드의 구현

자바에서 쓰레드를 구현하는 방법에는 크게 두가지가 있다.

### 1. Thread 클래스를 상속받아 구현

```java
public class MyThread extends Thread {
    public void run() {
        //작업
        System.out.println("MyThread run");
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("MyThread end");
    }
}
```

### 2. Runnable 인터페이스를 구현

```java
public class MyThread2 implements Runnable{
    @Override
    public void run() {
        //작업
        System.out.println("MyThread2 run");
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("MyThread2 end");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        Thread thread2 = new Thread(new MyThread2());

        thread.start();
        thread2.start();
    }
```

실행 결과

```
MyThread run
MyThread2 run
MyThread end
MyThread2 end
```

순서대로 Mythread가 종료된후 실행되는게 아니며 실행결과는 다를때도 있다.  
두 방법 모두 쓰레드를 통해 작업하고 싶은 내용을 run()메서드에 작성하면 되지만 Thread 클래스를 상속받아 구현할 경우 다른 클래스를 상속받을 수 없어서 그럴때는 Runnable 인터페이스를 구현하면 된다.

## run() start()

위에서 run()메서드를 구현하고 run()을 호출하지 않고 start()를 호출하였는데 이 둘은 차이가 있다.
<img src="https://github.com/yangseungin/TIL/blob/master/java/%EC%82%AC%EC%A7%84/run()%20start()%20%EC%B0%A8%EC%9D%B4.png?raw=true" width="80%">

- run()실행: 스레드를 실행하는게 아닌 단순히 메서드를 호출하는것으로 호출하게 되어 스레드가 아닌 순서대로 실행이된다.
- start()실행: 쓰레드가 작업에 필요한 `call stack`을 생성하고 run()을 호출하여 독립적으로 수행한다.

## Main 쓰레드

call stack을 보면 main메서드도 올라가있는데 main메서드의 작업을 수행하는 쓰레드를 main쓰레드라고 한다.  
main 메서드가 종료되더라도 다른 쓰레드에서 작업이 이루어지고 있다면 프로그램은 종료되지 않고 모든 작업이 끝난후에 프로그램이 종료되게 된다.

```java
public class MyThread extends Thread {
    public void run() {
        //작업
        System.out.println("MyThread run");
        try {
           Thread.sleep(3000);  //3초간 sleep하도록 변경
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("MyThread end");
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        Thread thread2 = new Thread(new MyThread2());

        thread.start();
        thread2.start();

        System.out.println("메인메서드 종료");
    }
}
```

실행 결과

```
메인메서드 종료
MyThread2 run
MyThread run
MyThread2 end
MyThread end

Process finished with exit code 0
```

3초후에 MyThread end가 출력되고 프로세스가 종료된다.

# 쓰레드의 상태

쓰레드는 총 5가지의 상태가 존재한다.

- NEW: 쓰레드가 생성되고 start()메서드가 호출되지 않은 상태
- RUNNABLE: 실행중이거나 실행가능한 상태
- BLOCKED: 동기화블럭에 의해 일시정지된 상태
- WAITING, TIMED_WAITING: 쓰레드의 작업이 종료되지 않았지만 실행가능하지않은 일시정지 상태
- TERMINATED: 쓰레드의 작업이 종료된 상태

# 쓰레드의 우선순위

쓰레드는 우선순위(priority)라는 멤버변수를 가지고 있으며 쓰레드의 중요도에 따라 우선순위를 다르게 지정하여 우선순위가 높은 쓰레드가 더 많은 시간동안 작업할수 있도록 설정할 수 있다.  
우선순위의 범위는 1~10이며 숫자가 클수록 높은 우선순위를 가지게 된다.  
또한 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.(Main쓰레드의 우선순위는 5이므로 main메서드에서 생성하는 쓰레드는 5가 된다.)

```java
public class Test {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        System.out.println(thread.getPriority());   //5
    }
}
```

# 동기화

# 데드락(Deadlock)

# 참고 문서

Java의 정석 - 남궁 성  
http://www.tcpschool.com/java/intro
